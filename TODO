h1. TODO

Here's a list of all I have planned to do in the future for Ruber. They're grouped
according to whether they're changes to the core of Ruber, to one of the existing
plugins or new plugins to be added. Entries inside each group don't follow a specific
order.

If an entry begins with a quotation mark, I'm not convinced it's a good idea.
Entries beginning with an exclamation mark are ideas which I deem difficult to
carry out

h2. Ruber Core

* ? Blocking signals. For example, if the user chooses to close a project, then
  chooses not to save one of the file, maybe the project shouldn't be closed at
  all. It can be implemented having slots connecting to the signal raising an
  ad-hoc exception. The emitting code rescues that exception and proceeds accordingly
* Add mimetype rules to the ProjectFiles extension
* Find out whether it's possible to remove the mnemonics from the main tab
  widget, as they overlap with other accelerators (menu and, most annoying for me,
  kate replace bar). If possible, maybe leave them as an option. [UPDATE] It seems
  that the responsible is KDE::TabWidget. While Qt::TabWidget adds the mnemonics
  only if the tab text explicitly contains and &, apparently KDE::TabWidget inserts
  it automatically if it doesn't exist. However, looking at the corresponding
  documentation, I don't understand where the change comes from
* ? Make the initialize methods of all the widgets meant to be subclassed take a block
  and handle it as Qt::Widget does (relying on the underlying implementation doesn't
  work because the block is called by the parent widget's initialize method, before
  much of the initialization has happened). Maybe, this could be considered a bug
  in qtruby (ask on the list). In that case, they could fix it by making the block
  call from new, rather than from initialize.
* Automatically generate project/config widgets from the file generated by rbuic,
  so that there's no more need to create a widget class whose only scope is to
  load the ui file
* Use icons of different sizes for different tasks
* Add a public ExternalProgramRunner#options_for method. It is used by other
  plugins which need to run the program to obtain the options
* !Do something so that saving a YamlOptionBackend is an atomic action (this means
  creating a temp file, writing to it then copying on the actual file. There might
  be permission problems)
* Add API to change the rules for the ProjectFiles extension
* !Find some way to allow the user to write to standard input when running
  programs (both for programs being developed and external programs)
* Put all classes created by rbuic under the Ruber::Ui namespace
* !See whether it's possible to break a long line of ruby output into several shorter
  lines in @OutputWidget@
* add toolbars
* !add a system to override actions, so that a plugin can replace the functionality
  provided by an action of another plugin with its own. This is quite complex, as
  it would require keeping trace of the slots connected to the actions.
* !When running and external program using the @RunnerPlugin@ class, if the program
  sends output continuosly (as in @loop do;puts "hello";end@), Ruber freezes. Do
  something about it (it can be done either in the @RunnerPlugin@ or in the
  @OutputWidget@ class)
* find out a better way to display relative path options in configuration dialog.
  Currently, the full path is displayed, but this isn't optimal.
* Rewrite the multi-html rspec formatter (used to run Ruber's own specs)
* Add a template system for projects
* Recognize ansi escape sequences in @OutputWidget@
* Add a caching mechanism for the plugins to load at startup. It should work
  this way: when the plugins are changed (that is, from the MainWindow#choose_plugins)
  method, a plugins_changed is emitted. The application connects to this signal
  and creates/updates a file containing the names of the plugins to load. This 
  file should be located (I think) in $KDEHOME/share/config/apps/ruber. At startup,
  see whether this file is newer than both the ruberrc file and of the PDF of all
  plugins mentioned in it. If so, dont re-compute the dependencies, but use those
  in the cache. Otherwise, re-compute them. For this to work, when the config file
  is written, the date of the cache file should be changed (using touch)
* Add a way for plugins to add actions to the RMB menu of the editor
* Add support from non editor widgets in the main tab bar
* !Find a way to have @OutputWidget@ give focus to the editor whenever a key it
  doesn't recognize is pressed and have that @KeyEvent@ passed to the editor
* !When the bottom tool widget becomes visible, have the editor scroll so that the
  line which was at the bottom remains visible. Currently, instead, the editor view
  is resized and the bottom lines are hidden. I don't know whether this is possible.
  Neither Kate nor KDevelop do it. KDevelop 3 did it instead.
* Add an entry displaying the number of rows in the current file to the statusbar
* In the @ProjectFilesList@ extension, make #scan_project use #file_in_project?, if
  possible
* Add a way to specify the order in which pages should be displayed in the
  configuration dialogs (maybe adding a priority attribute somewhere in the PSF)
* Allow sorting tabs by drag and drop
* ?Per-project recent file list. The behaviour should be very well thought,
  to avoid the mistakes done by kate.

h2. Plugins

* Put all classes created by rbuic under the Ruber::Ui namespace
* add toolbars

h3. RSpec plugin

* Better management of subdirectories for spec files. At least, subdirectories
  of the spec directory should be searched for files. It would be better if one
  could define several spec directories, depending on some pattern.

h3. Ruber Development

* !Add a way to specify commands to be run before running the current project, so
  that, for example, the user can run rake to make sure that files which are automatically
  generated (for example, ruby files from .ui files) are up-to-date
  
h3. Find in Files

* Split the @ReplaceWidget@ class that the actual
  replacement is carried on by another class (either the plugin class or a new
  one). The tool widget should only concern itself with displaying the results.
  Also, replace many block connections with true slots
* If in regexp mode, and the find line edit contains an invalid regexp, detect it,
  disable the @Find@ and @Replace@ buttons and display a warning
  
h3. Syntax Checker

* Put the ruby and yaml syntax checkers in a separate plugin
* See whether it's possible to have syntax checking for unsaved files (of course,
  if the user sets the mode or the highlighting properties for the document)
  
h3. Command

* !Replace the tool widget with an irb-based tool widget, if possible
  
h2. New plugins

h3. Quick Open File

* move the Quick Open File action and dialog to a separate plugin
* Add completion to the Quick open file dialog

h3. Quick open method/class plugin

h3. ri plugin

h3. irb plugin

h3. Konsole plugin

h3. File system browser plugin

h3. Ruby parser plugin

h3. Class browser plugin

h3. Autocompletion plugin

This should be based on the ruby parser plugin and provide intelligent autocompletion

h3. VCS plugins

There should be plugins for various version control system - at least subversion
and git, and maybe a generic VCS plugin

h3. Ruby formatter plugin

h3. Snippets plugin

h3. Debugger plugin
